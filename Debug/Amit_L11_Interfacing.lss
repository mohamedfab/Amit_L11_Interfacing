
Amit_L11_Interfacing.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  000002d8  0000036c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  00800060  00800060  0000036c  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  0000036c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000097  00000000  00000000  00000a38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  00000acf  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000158  00000000  00000000  00000afe  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000123c  00000000  00000000  00000c56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000056f  00000000  00000000  00001e92  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000006c8  00000000  00000000  00002401  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000029c  00000000  00000000  00002acc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000005f5  00000000  00000000  00002d68  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001064  00000000  00000000  0000335d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000128  00000000  00000000  000043c1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
		break;
	}
}
void ExtInt_SnsCtrlSet(Int_ID extIntID,Sense_Mode_ID intSense)
{
	switch (extIntID)
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	{
	case INT0:
		EXTINT_MCUCR_REG|=intSense<<EXT_INT0_SENSE_BIT;
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		break;

	case INT1:
		EXTINT_MCUCR_REG|=intSense<<EXT_INT1_SENSE_BIT;
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		break;

	case INT2:
		if (intSense == FAILING_EDGE_MODE)
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		{
			CLEAR_BIT(EXTINT_MCUCSR_REG,EXT_INT2_SENSE_BIT);
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
		}
		else if (intSense == RISING_EDGE_MODE)
  2c:	0c 94 2b 01 	jmp	0x256	; 0x256 <__vector_11>
		{
			SET_BIT(EXTINT_MCUCSR_REG,EXT_INT2_SENSE_BIT);
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	Dio_ConfigChannel(LCD_RS_PORT, LCD_RS_CHANNEL, OUTPUT);
	Dio_ConfigChannel(LCD_RW_PORT, LCD_RW_CHANNEL, OUTPUT);
	Dio_ConfigChannel(LCD_EN_PORT, LCD_EN_CHANNEL, OUTPUT);

	Dio_ConfigChannels(LCD_DATA_PORT, LCD_MASK, OUTPUT);
	Dio_WriteChannel(LCD_RW_PORT, LCD_RW_CHANNEL, STD_LOW);
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

	_delay_ms(15);
	Lcd_Cmd(0x03);
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
	_delay_ms(5);
	Lcd_Cmd(0x03);
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 ed       	ldi	r30, 0xD8	; 216
  68:	f2 e0       	ldi	r31, 0x02	; 2
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
	_delay_us(100);
	Lcd_Cmd(0x03);
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
	Lcd_Cmd(0x02);
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
	Lcd_Cmd(_LCD_4BIT_MODE);
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a1 36       	cpi	r26, 0x61	; 97
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 5d 01 	call	0x2ba	; 0x2ba <main>
  8a:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <_exit>

0000008e <__bad_interrupt>:
			{
				Lcd_DisplayChr(customChar[loc_CharIndx][loc_ByteIndex]);
			}
	}
}
void Lcd_Init(void)
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Dio_ConfigChannel>:
{
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
	{
		Lcd_Cmd(_LCD_CGRAM_START_ADDRESS +(loc_CharIndx*8));
  92:	81 30       	cpi	r24, 0x01	; 1
  94:	21 f1       	breq	.+72     	; 0xde <Dio_ConfigChannel+0x4c>
  96:	30 f0       	brcs	.+12     	; 0xa4 <Dio_ConfigChannel+0x12>
			{
				Lcd_DisplayChr(customChar[loc_CharIndx][loc_ByteIndex]);
			}
	}
}
void Lcd_Init(void)
  98:	82 30       	cpi	r24, 0x02	; 2
  9a:	f1 f1       	breq	.+124    	; 0x118 <Dio_ConfigChannel+0x86>
  9c:	83 30       	cpi	r24, 0x03	; 3
  9e:	09 f0       	breq	.+2      	; 0xa2 <Dio_ConfigChannel+0x10>
  a0:	74 c0       	rjmp	.+232    	; 0x18a <Dio_ConfigChannel+0xf8>
  a2:	57 c0       	rjmp	.+174    	; 0x152 <Dio_ConfigChannel+0xc0>
  a4:	41 11       	cpse	r20, r1
  a6:	0e c0       	rjmp	.+28     	; 0xc4 <Dio_ConfigChannel+0x32>
  a8:	2a b3       	in	r18, 0x1a	; 26
  aa:	81 e0       	ldi	r24, 0x01	; 1
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
	{
		Lcd_Cmd(_LCD_CGRAM_START_ADDRESS +(loc_CharIndx*8));
			for (loc_ByteIndex =0; loc_ByteIndex<NO_CSTOM_CHAR_BYTES;loc_ByteIndex++)
			{
				Lcd_DisplayChr(customChar[loc_CharIndx][loc_ByteIndex]);
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	ac 01       	movw	r20, r24
  b0:	02 c0       	rjmp	.+4      	; 0xb6 <Dio_ConfigChannel+0x24>
  b2:	44 0f       	add	r20, r20
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
	{
		Lcd_Cmd(_LCD_CGRAM_START_ADDRESS +(loc_CharIndx*8));
			for (loc_ByteIndex =0; loc_ByteIndex<NO_CSTOM_CHAR_BYTES;loc_ByteIndex++)
  b4:	55 1f       	adc	r21, r21
  b6:	6a 95       	dec	r22
  b8:	e2 f7       	brpl	.-8      	; 0xb2 <Dio_ConfigChannel+0x20>
  ba:	ba 01       	movw	r22, r20
  bc:	60 95       	com	r22
}
static void Lcd_WriteCustom(void)
{
	u8 loc_ByteIndex=0;
	u8 loc_CharIndx=0;
	for (loc_CharIndx=0;loc_CharIndx<NO_CSTOM_CHAR;loc_CharIndx++)
  be:	62 23       	and	r22, r18
  c0:	6a bb       	out	0x1a, r22	; 26
  c2:	08 95       	ret
	_delay_us(100);
	Lcd_Cmd(0x03);
	Lcd_Cmd(0x02);
	Lcd_Cmd(_LCD_4BIT_MODE);
	Lcd_WriteCustom();
	Lcd_GoToRowColumn(0, 0);
  c4:	2a b3       	in	r18, 0x1a	; 26
  c6:	81 e0       	ldi	r24, 0x01	; 1
  c8:	90 e0       	ldi	r25, 0x00	; 0
  ca:	ac 01       	movw	r20, r24
}
  cc:	02 c0       	rjmp	.+4      	; 0xd2 <Dio_ConfigChannel+0x40>
  ce:	44 0f       	add	r20, r20
  d0:	55 1f       	adc	r21, r21
  d2:	6a 95       	dec	r22
  d4:	e2 f7       	brpl	.-8      	; 0xce <Dio_ConfigChannel+0x3c>
  d6:	ba 01       	movw	r22, r20
  d8:	62 2b       	or	r22, r18
  da:	6a bb       	out	0x1a, r22	; 26
		}
		break;
	case DIO_PORTD:
		if (level == STD_LOW)
		{
			CLEAR_BIT(DIO_PORTD_REG,channel);
  dc:	08 95       	ret
  de:	41 11       	cpse	r20, r1
		}
		else
		{
			SET_BIT(DIO_PORTD_REG,channel);
  e0:	0e c0       	rjmp	.+28     	; 0xfe <Dio_ConfigChannel+0x6c>
  e2:	27 b3       	in	r18, 0x17	; 23
  e4:	81 e0       	ldi	r24, 0x01	; 1
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	ac 01       	movw	r20, r24
  ea:	02 c0       	rjmp	.+4      	; 0xf0 <Dio_ConfigChannel+0x5e>
  ec:	44 0f       	add	r20, r20
  ee:	55 1f       	adc	r21, r21
  f0:	6a 95       	dec	r22
  f2:	e2 f7       	brpl	.-8      	; 0xec <Dio_ConfigChannel+0x5a>
  f4:	ba 01       	movw	r22, r20
  f6:	60 95       	com	r22
  f8:	62 23       	and	r22, r18
		}
		break;
	case DIO_PORTB:
		if (direction == INPUT)
		{
			CLEAR_BIT(DIO_DDRB_REG,channel);
  fa:	67 bb       	out	0x17, r22	; 23
  fc:	08 95       	ret
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,channel);
  fe:	27 b3       	in	r18, 0x17	; 23
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	ac 01       	movw	r20, r24
 106:	02 c0       	rjmp	.+4      	; 0x10c <Dio_ConfigChannel+0x7a>
 108:	44 0f       	add	r20, r20
 10a:	55 1f       	adc	r21, r21
 10c:	6a 95       	dec	r22
 10e:	e2 f7       	brpl	.-8      	; 0x108 <Dio_ConfigChannel+0x76>
 110:	ba 01       	movw	r22, r20
 112:	62 2b       	or	r22, r18
 114:	67 bb       	out	0x17, r22	; 23
 116:	08 95       	ret
		}
		break;
	case DIO_PORTC:
		if (direction == INPUT)
 118:	41 11       	cpse	r20, r1
 11a:	0e c0       	rjmp	.+28     	; 0x138 <Dio_ConfigChannel+0xa6>
		{
			CLEAR_BIT(DIO_DDRC_REG,channel);
 11c:	24 b3       	in	r18, 0x14	; 20
 11e:	81 e0       	ldi	r24, 0x01	; 1
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	ac 01       	movw	r20, r24
 124:	02 c0       	rjmp	.+4      	; 0x12a <Dio_ConfigChannel+0x98>
 126:	44 0f       	add	r20, r20
 128:	55 1f       	adc	r21, r21
 12a:	6a 95       	dec	r22
 12c:	e2 f7       	brpl	.-8      	; 0x126 <Dio_ConfigChannel+0x94>
 12e:	ba 01       	movw	r22, r20
 130:	60 95       	com	r22
 132:	62 23       	and	r22, r18
 134:	64 bb       	out	0x14, r22	; 20
 136:	08 95       	ret
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,channel);
 138:	24 b3       	in	r18, 0x14	; 20
 13a:	81 e0       	ldi	r24, 0x01	; 1
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	ac 01       	movw	r20, r24
 140:	02 c0       	rjmp	.+4      	; 0x146 <Dio_ConfigChannel+0xb4>
 142:	44 0f       	add	r20, r20
 144:	55 1f       	adc	r21, r21
 146:	6a 95       	dec	r22
 148:	e2 f7       	brpl	.-8      	; 0x142 <Dio_ConfigChannel+0xb0>
 14a:	ba 01       	movw	r22, r20
 14c:	62 2b       	or	r22, r18
 14e:	64 bb       	out	0x14, r22	; 20
 150:	08 95       	ret
		}
		break;
	case DIO_PORTD:
		if (direction == INPUT)
 152:	41 11       	cpse	r20, r1
 154:	0e c0       	rjmp	.+28     	; 0x172 <Dio_ConfigChannel+0xe0>
		{
			CLEAR_BIT(DIO_DDRD_REG,channel);
 156:	21 b3       	in	r18, 0x11	; 17
 158:	81 e0       	ldi	r24, 0x01	; 1
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	ac 01       	movw	r20, r24
 15e:	02 c0       	rjmp	.+4      	; 0x164 <Dio_ConfigChannel+0xd2>
 160:	44 0f       	add	r20, r20
 162:	55 1f       	adc	r21, r21
 164:	6a 95       	dec	r22
 166:	e2 f7       	brpl	.-8      	; 0x160 <Dio_ConfigChannel+0xce>
 168:	ba 01       	movw	r22, r20
 16a:	60 95       	com	r22
 16c:	62 23       	and	r22, r18
 16e:	61 bb       	out	0x11, r22	; 17
 170:	08 95       	ret
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,channel);
 172:	21 b3       	in	r18, 0x11	; 17
 174:	81 e0       	ldi	r24, 0x01	; 1
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	ac 01       	movw	r20, r24
 17a:	02 c0       	rjmp	.+4      	; 0x180 <Dio_ConfigChannel+0xee>
 17c:	44 0f       	add	r20, r20
 17e:	55 1f       	adc	r21, r21
 180:	6a 95       	dec	r22
 182:	e2 f7       	brpl	.-8      	; 0x17c <Dio_ConfigChannel+0xea>
 184:	ba 01       	movw	r22, r20
 186:	62 2b       	or	r22, r18
 188:	61 bb       	out	0x11, r22	; 17
 18a:	08 95       	ret

0000018c <Dio_FlipChannel>:
		break;
	}
}
void Dio_FlipChannel(Dio_Port port,Dio_Channel channel)
{
	switch (port)
 18c:	81 30       	cpi	r24, 0x01	; 1
 18e:	99 f0       	breq	.+38     	; 0x1b6 <Dio_FlipChannel+0x2a>
 190:	28 f0       	brcs	.+10     	; 0x19c <Dio_FlipChannel+0x10>
 192:	82 30       	cpi	r24, 0x02	; 2
 194:	e9 f0       	breq	.+58     	; 0x1d0 <Dio_FlipChannel+0x44>
 196:	83 30       	cpi	r24, 0x03	; 3
 198:	a1 f5       	brne	.+104    	; 0x202 <Dio_FlipChannel+0x76>
 19a:	27 c0       	rjmp	.+78     	; 0x1ea <Dio_FlipChannel+0x5e>
	{
	case DIO_PORTA:
		TOGGLE_BIT(DIO_PORTA_REG,channel);
 19c:	2b b3       	in	r18, 0x1b	; 27
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	90 e0       	ldi	r25, 0x00	; 0
 1a2:	ac 01       	movw	r20, r24
 1a4:	02 c0       	rjmp	.+4      	; 0x1aa <Dio_FlipChannel+0x1e>
 1a6:	44 0f       	add	r20, r20
 1a8:	55 1f       	adc	r21, r21
 1aa:	6a 95       	dec	r22
 1ac:	e2 f7       	brpl	.-8      	; 0x1a6 <Dio_FlipChannel+0x1a>
 1ae:	ba 01       	movw	r22, r20
 1b0:	62 27       	eor	r22, r18
 1b2:	6b bb       	out	0x1b, r22	; 27
		break;
 1b4:	08 95       	ret
	case DIO_PORTB:
		TOGGLE_BIT(DIO_PORTB_REG,channel);
 1b6:	28 b3       	in	r18, 0x18	; 24
 1b8:	81 e0       	ldi	r24, 0x01	; 1
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	ac 01       	movw	r20, r24
 1be:	02 c0       	rjmp	.+4      	; 0x1c4 <Dio_FlipChannel+0x38>
 1c0:	44 0f       	add	r20, r20
 1c2:	55 1f       	adc	r21, r21
 1c4:	6a 95       	dec	r22
 1c6:	e2 f7       	brpl	.-8      	; 0x1c0 <Dio_FlipChannel+0x34>
 1c8:	ba 01       	movw	r22, r20
 1ca:	62 27       	eor	r22, r18
 1cc:	68 bb       	out	0x18, r22	; 24
		break;
 1ce:	08 95       	ret
	case DIO_PORTC:
		TOGGLE_BIT(DIO_PORTC_REG,channel);
 1d0:	25 b3       	in	r18, 0x15	; 21
 1d2:	81 e0       	ldi	r24, 0x01	; 1
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	ac 01       	movw	r20, r24
 1d8:	02 c0       	rjmp	.+4      	; 0x1de <Dio_FlipChannel+0x52>
 1da:	44 0f       	add	r20, r20
 1dc:	55 1f       	adc	r21, r21
 1de:	6a 95       	dec	r22
 1e0:	e2 f7       	brpl	.-8      	; 0x1da <Dio_FlipChannel+0x4e>
 1e2:	ba 01       	movw	r22, r20
 1e4:	62 27       	eor	r22, r18
 1e6:	65 bb       	out	0x15, r22	; 21
		break;
 1e8:	08 95       	ret
	case DIO_PORTD:
		TOGGLE_BIT(DIO_PORTD_REG,channel);
 1ea:	22 b3       	in	r18, 0x12	; 18
 1ec:	81 e0       	ldi	r24, 0x01	; 1
 1ee:	90 e0       	ldi	r25, 0x00	; 0
 1f0:	ac 01       	movw	r20, r24
 1f2:	02 c0       	rjmp	.+4      	; 0x1f8 <Dio_FlipChannel+0x6c>
 1f4:	44 0f       	add	r20, r20
 1f6:	55 1f       	adc	r21, r21
 1f8:	6a 95       	dec	r22
 1fa:	e2 f7       	brpl	.-8      	; 0x1f4 <Dio_FlipChannel+0x68>
 1fc:	ba 01       	movw	r22, r20
 1fe:	62 27       	eor	r22, r18
 200:	62 bb       	out	0x12, r22	; 18
 202:	08 95       	ret

00000204 <EnableAllInterrupts>:
 *      Author: Eng_Fawzi
 */
#include "GlblInterrupt_Interface.h"
void EnableAllInterrupts()
{
	SET_BIT(GLBLINT_SREG_REG,I_BIT_POS);
 204:	8f b7       	in	r24, 0x3f	; 63
 206:	80 68       	ori	r24, 0x80	; 128
 208:	8f bf       	out	0x3f, r24	; 63
 20a:	08 95       	ret

0000020c <Led_Init>:

#include "Led_Interface.h"

void Led_Init(void)
{
	Dio_ConfigChannel(LED0_PORT, LED0_CHANNEL, OUTPUT);
 20c:	41 e0       	ldi	r20, 0x01	; 1
 20e:	62 e0       	ldi	r22, 0x02	; 2
 210:	82 e0       	ldi	r24, 0x02	; 2
 212:	0e 94 49 00 	call	0x92	; 0x92 <Dio_ConfigChannel>
	Dio_ConfigChannel(LED1_PORT, LED1_CHANNEL, OUTPUT);
 216:	41 e0       	ldi	r20, 0x01	; 1
 218:	67 e0       	ldi	r22, 0x07	; 7
 21a:	82 e0       	ldi	r24, 0x02	; 2
 21c:	0e 94 49 00 	call	0x92	; 0x92 <Dio_ConfigChannel>
	Dio_ConfigChannel(LED2_PORT, LED2_CHANNEL, OUTPUT);
 220:	41 e0       	ldi	r20, 0x01	; 1
 222:	63 e0       	ldi	r22, 0x03	; 3
 224:	83 e0       	ldi	r24, 0x03	; 3
 226:	0e 94 49 00 	call	0x92	; 0x92 <Dio_ConfigChannel>
 22a:	08 95       	ret

0000022c <Led_Toggle>:
		break;
	}
}
void Led_Toggle(Led_ID led)
{
	switch (led)
 22c:	81 30       	cpi	r24, 0x01	; 1
 22e:	49 f0       	breq	.+18     	; 0x242 <Led_Toggle+0x16>
 230:	18 f0       	brcs	.+6      	; 0x238 <Led_Toggle+0xc>
 232:	82 30       	cpi	r24, 0x02	; 2
 234:	79 f4       	brne	.+30     	; 0x254 <Led_Toggle+0x28>
 236:	0a c0       	rjmp	.+20     	; 0x24c <Led_Toggle+0x20>
	{
	case LED0:
		Dio_FlipChannel(LED0_PORT,LED0_CHANNEL);
 238:	62 e0       	ldi	r22, 0x02	; 2
 23a:	82 e0       	ldi	r24, 0x02	; 2
 23c:	0e 94 c6 00 	call	0x18c	; 0x18c <Dio_FlipChannel>
		break;
 240:	08 95       	ret
	case LED1:
		Dio_FlipChannel(LED1_PORT,LED1_CHANNEL);
 242:	67 e0       	ldi	r22, 0x07	; 7
 244:	82 e0       	ldi	r24, 0x02	; 2
 246:	0e 94 c6 00 	call	0x18c	; 0x18c <Dio_FlipChannel>
		break;
 24a:	08 95       	ret
	case LED2:
		Dio_FlipChannel(LED2_PORT,LED2_CHANNEL);
 24c:	63 e0       	ldi	r22, 0x03	; 3
 24e:	83 e0       	ldi	r24, 0x03	; 3
 250:	0e 94 c6 00 	call	0x18c	; 0x18c <Dio_FlipChannel>
 254:	08 95       	ret

00000256 <__vector_11>:
#define TIMER0_START_VALUE	(100)
#define PRESCALLER_1024		(5)

volatile u8 count=0;
ISR(TIMER0_OVF_vect)
{
 256:	1f 92       	push	r1
 258:	0f 92       	push	r0
 25a:	0f b6       	in	r0, 0x3f	; 63
 25c:	0f 92       	push	r0
 25e:	11 24       	eor	r1, r1
 260:	2f 93       	push	r18
 262:	3f 93       	push	r19
 264:	4f 93       	push	r20
 266:	5f 93       	push	r21
 268:	6f 93       	push	r22
 26a:	7f 93       	push	r23
 26c:	8f 93       	push	r24
 26e:	9f 93       	push	r25
 270:	af 93       	push	r26
 272:	bf 93       	push	r27
 274:	ef 93       	push	r30
 276:	ff 93       	push	r31
	count++;
 278:	80 91 60 00 	lds	r24, 0x0060
 27c:	8f 5f       	subi	r24, 0xFF	; 255
 27e:	80 93 60 00 	sts	0x0060, r24
	if (count == NO_OF_OVERFLOWS)
 282:	80 91 60 00 	lds	r24, 0x0060
 286:	84 36       	cpi	r24, 0x64	; 100
 288:	29 f4       	brne	.+10     	; 0x294 <__vector_11+0x3e>
	{
	 /*	Take Your Action	*/
	 
	 Led_Toggle(LED0);
 28a:	80 e0       	ldi	r24, 0x00	; 0
 28c:	0e 94 16 01 	call	0x22c	; 0x22c <Led_Toggle>
	 count=0;
 290:	10 92 60 00 	sts	0x0060, r1
	}
	TIMER0_TCNT0_REG = TIMER0_START_VALUE;
 294:	84 e6       	ldi	r24, 0x64	; 100
 296:	82 bf       	out	0x32, r24	; 50
}
 298:	ff 91       	pop	r31
 29a:	ef 91       	pop	r30
 29c:	bf 91       	pop	r27
 29e:	af 91       	pop	r26
 2a0:	9f 91       	pop	r25
 2a2:	8f 91       	pop	r24
 2a4:	7f 91       	pop	r23
 2a6:	6f 91       	pop	r22
 2a8:	5f 91       	pop	r21
 2aa:	4f 91       	pop	r20
 2ac:	3f 91       	pop	r19
 2ae:	2f 91       	pop	r18
 2b0:	0f 90       	pop	r0
 2b2:	0f be       	out	0x3f, r0	; 63
 2b4:	0f 90       	pop	r0
 2b6:	1f 90       	pop	r1
 2b8:	18 95       	reti

000002ba <main>:

int main(void)
{
	Led_Init();
 2ba:	0e 94 06 01 	call	0x20c	; 0x20c <Led_Init>
	EnableAllInterrupts();
 2be:	0e 94 02 01 	call	0x204	; 0x204 <EnableAllInterrupts>
	TIMER0_TCNT0_REG = TIMER0_START_VALUE;
 2c2:	84 e6       	ldi	r24, 0x64	; 100
 2c4:	82 bf       	out	0x32, r24	; 50
	/*	Enable Timer0 Overflow Interrupt	*/
	SET_BIT(TIMER0_TIMSK_REG,OVERFLOW_INT_EN_BIT);
 2c6:	89 b7       	in	r24, 0x39	; 57
 2c8:	81 60       	ori	r24, 0x01	; 1
 2ca:	89 bf       	out	0x39, r24	; 57
	/*	Set Timer0 Prescaller to /1024	*/
	/*	Start Timer	*/
	TIMER0_TCCR0_REG|=PRESCALLER_1024;
 2cc:	83 b7       	in	r24, 0x33	; 51
 2ce:	85 60       	ori	r24, 0x05	; 5
 2d0:	83 bf       	out	0x33, r24	; 51
 2d2:	ff cf       	rjmp	.-2      	; 0x2d2 <main+0x18>

000002d4 <_exit>:
 2d4:	f8 94       	cli

000002d6 <__stop_program>:
 2d6:	ff cf       	rjmp	.-2      	; 0x2d6 <__stop_program>
